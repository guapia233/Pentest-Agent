# 创建两个Agent,一个是自己发布命令给执行的Agents，让他来做任务使用工具
# 1.创建人类Agents

import autogen
import sys
# import es
sys.path.append("/home/kali/Agent/Agent-main-master/")
sys.path.append("/home/kali/Agent/Agent-main-master/config")
sys.path.append("/home/kali/Agent/Agent-main-master/contant")
sys.path.append("/home/kali/Agent/Agent-main-master/es")

import gradio as gr
import os
from pathlib import Path
import autogen
import chromadb
import multiprocessing as mp
from autogen.retrieve_utils import TEXT_FORMATS, get_file_from_url, is_url
from autogen.agentchat.contrib.retrieve_assistant_agent import RetrieveAssistantAgent
from autogen.agentchat.contrib.retrieve_user_proxy_agent import (
    RetrieveUserProxyAgent,
    PROMPT_CODE,
)
from elasticsearch import Elasticsearch



from config.llmConfig import LLM_CONFIG, CONFIG_LLM
from tool import network_scanTool, port_scanTool, web_scanTool, scanTool, msfconsoleTool, searchMatchingModulesTool, moduleTool, attackTool, meterpreter

# assistant = autogen.AssistantAgent(
#     name="Assistant",
#     system_message="只能使用提供给您的工具。任务完成后回复TERMINATE。",
#     llm_config=LLM_CONFIG,  # 配置文件主要是以[]的类型进行存放
# )

assistant = RetrieveAssistantAgent(
    name="assistant",
    system_message="只能使用提供给您的工具。任务完成后回复TERMINATE。",
    llm_config=LLM_CONFIG,  # 配置文件主要是以[]的类型进行存放
)

ragproxyagent = RetrieveUserProxyAgent(
    name="ragproxyagent",
    is_termination_msg=lambda x: x.get("content", "") and x.get("content", "").rstrip().endswith("TERMINATE"),
    # 人类提供意见
    human_input_mode="ALWAYS",
    # 最大交流轮次为10，这个暂时先放着
    max_consecutive_auto_reply=10,
    # code_execution_config={
    #     # "work_dir": "coding",
    #     "use_docker": False,
    # },
    retrieve_config={
        "task": "code",
        "docs_path": [
            "https://raw.githubusercontent.com/microsoft/FLAML/main/website/docs/Examples/Integrate%20-%20Spark.md",
            "https://raw.githubusercontent.com/microsoft/FLAML/main/website/docs/Research.md",
            os.path.join(os.path.abspath(""), "..", "website", "docs"),
        ],
        "custom_text_types": ["mdx"],
        "chunk_token_size": 2000,
        "model": CONFIG_LLM[0]["model"],
        "vector_db": "pgvector",
        "collection_name": "autogen_docs",
        "db_config": {
            "connection_string": "postgresql://testuser:testpwd@localhost:5432/vectordb",
            # Optional - connect to an external vector database
            # "host": None, # Optional vector database host
            # "port": None, # Optional vector database port
            # "database": None, # Optional vector database name
            # "username": None, # Optional vector database username
            # "password": None, # Optional vector database password
        },
        "client": Elasticsearch(hosts=["http://192.168.92.131:9200"]),
        "embedding_model": "all-mpnet-base-v2",
        "get_or_create": True,  # set to False if you don't want to reuse an existing collection, but you'll need to remove the collection manually
    },
)


# userProxy = autogen.UserProxyAgent(
#     name="user_proxy",
#     # 一个以字典形式接收消息的函数并且返回指示该接收到的消息是否是终止消息的布尔值。
#     is_termination_msg=lambda x: x.get("content", "") and x.get("content", "").rstrip().endswith("TERMINATE"),
#     # 人类提供意见
#     human_input_mode="ALWAYS",
#     # 最大交流轮次为10，这个暂时先放着
#     max_consecutive_auto_reply=10,
#     code_execution_config={
#         # "work_dir": "coding",
#         "use_docker": False,
#     },
#     # Please set use_docker=True if docker is available to run the generated code. Using docker is safer than running the generated code directly.
# )


#为什么在这里需要同时注入 暂时的理解是需要在userAgent中注册函数，但不一定
assistant.register_function(
    function_map={
        network_scanTool.name: network_scanTool._run,
        port_scanTool.name: port_scanTool._run,
        web_scanTool.name: web_scanTool._run,
        scanTool.name: scanTool._run,
        msfconsoleTool.name: msfconsoleTool._run,
        searchMatchingModulesTool.name: searchMatchingModulesTool._run,

        moduleTool.name: moduleTool._run,
        attackTool.name: attackTool._run,
        meterpreter.name: meterpreter._run
    }
)
userProxy.register_function(
    function_map= {
        network_scanTool.name: network_scanTool._run,
        port_scanTool.name: port_scanTool._run,
        web_scanTool.name: web_scanTool._run,
        scanTool.name: scanTool._run,
        msfconsoleTool.name: msfconsoleTool._run,
        searchMatchingModulesTool.name: searchMatchingModulesTool._run,

        moduleTool.name: moduleTool._run,
        attackTool.name: attackTool._run,
        meterpreter.name: meterpreter._run
    }
)
# 4.执行
userProxy.initiate_chat(assistant,
                        # message="请先确定靶机的IP地址，再使用工具扫描靶机端口和web目录信息，靶机所在网段为192.168.92.0/24")
                        message="请获得靶机root权限")

