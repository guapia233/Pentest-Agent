from langchain.memory import ConversationBufferMemory
from langchain.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain.tools.render import format_tool_to_openai_function
from langchain.agents.format_scratchpad import format_to_openai_functions
from tool import tools
functions = [format_tool_to_openai_function(f) for f in tools]
from langchain_community.chat_models.openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from langchain.prompts import MessagesPlaceholder
from langchain.agents.output_parsers import OpenAIFunctionsAgentOutputParser

# 创建prompt
# agent_scratchpad变量时用来存储chain的首次调用结果和外部函数的返回结果：
prompt = ChatPromptTemplate.from_messages([
    ("system", "You are a helpful and fashionable assistant. Please answer the user's question based on the retrieved "
               "text. If the content is retrieved, return the retrieved text directly"),
    ("user", "{input}"),
    MessagesPlaceholder(variable_name="agent_scratchpad")
])
llm_with_tools = ChatOpenAI().bind(functions=functions)

agent = {
            "input": lambda x: x["input"],
            "agent_scratchpad": lambda x: format_to_openai_functions(x['intermediate_steps'])
        } | prompt | llm_with_tools | OpenAIFunctionsAgentOutputParser()

from langchain.agents import AgentExecutor
memory = ConversationBufferMemory(memory_key="chat_history")
agent_executor = AgentExecutor(agent=agent, tools=tools, memory =memory,verbose=True)

agent_executor.invoke({"input": " 当目标靶机IP未知时，告诉我执行攻击渗透要怎么做,攻击机的网段是192.168.60.0/24"
                                })
